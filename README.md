<H1>PATTERN pt2</H1>

<h2>
  1. Decorator (Structural Pattern)
</h2>
<p>
  The Decorator pattern is used to add new functionality to an object dynamically without altering its structure. It involves a set of decorator classes that are used to wrap concrete components.

Key Points:
Allows behavior to be added to individual objects, either statically or dynamically.
Promotes the Open-Closed Principle (open for extension, closed for modification).
</p>
<h2>
  2. Adapter (Structural Pattern)
</h2>

<p>
  The Adapter pattern allows incompatible interfaces to work together. It acts as a bridge between two interfaces, converting one interface into another that the client expects.

Key Points:
Useful when you want to use an existing class but its interface does not match the one you need.
Promotes the Single Responsibility Principle (separates interface conversion logic from business logic).
</p>

<h2>
  3. Facade (Structural Pattern)
</h2>

<p>
  The Facade pattern provides a simplified interface to a larger body of code, hiding complexities and making subsystems easier to use.

Key Points:
Useful when working with complex subsystems.
Promotes loose coupling between subsystems and clients.
</p>

<h2>
  4. Strategy (Behavioral Pattern)
</h2>

<p>
  The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows the algorithm to vary independently from clients that use it.

Key Points:
Promotes the Open-Closed Principle (new strategies can be added without modifying existing ones).
Useful when you need different variants of an algorithm.
</p>
